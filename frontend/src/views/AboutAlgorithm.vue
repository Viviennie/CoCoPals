<template>
    <StickyNavbar/>
  
    <img src="/about.png" alt="Banner Image" class="banner-image" />
  
    <div class="text-container">
      <div class="text">
        <h1 style="margin: 50px;margin-left: 0;">How Does the Collaboration Works?</h1>
        <nav class="article-nav">
          <ul>
            <!-- 动态生成导航链接 -->
            <li v-for="(section, index) in sections" :key="index" 
                :class="{ active: activeSection === section.id }"
                @click="scrollToSection(section.id)">
              <a :href="`#${section.id}`">{{ section.title }}</a>
            </li>
          </ul>
        </nav>
        <section v-for="(section, index) in sections" :key="index" :id="section.id">
          <p v-html="section.htmlf+section.title+section.htmll"></p>
          <p v-html="section.content"></p>
          <br><br>
        </section>
      </div>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted, onUnmounted } from 'vue';
  import StickyNavbar from '../components/Navbar.vue';
  
  // 定义章节数据
  const sections = ref([
    {
        id: 'section1',
        htmlf: '<h2>',
        htmll: '</h2>',
        title: 'Introduction to the OT Algorithm',
        content: 'The fundamental idea of the OT (Operational Transformation) algorithm is used to maintain consistency in collaborative editing, which plays a crucial role in our project. This document aims to introduce the basic concepts of the OT algorithm.'
    },
    {
        id: 'section2',
        htmlf: '<h2>',
        htmll: '</h2>',
        title: 'Persistent Thought of the OT Algorithm',
        content: 'We can use an example to understand this concept more simply:\n\nFor instance, assume the initial text contains the string "abc," which is replicated at two collaborative editing sites. At both sites, two operations are generated simultaneously: O1 = Insert[0, "x"] (insert character "x" at position 0) and O2 = Delete[2, 1] (delete one character at position 2, i.e., "c"), generated by users at sites 1 and 2, respectively. Under the control of the OT algorithm, local operations are executed directly, while remote operations are transformed before execution.\n\nThe specific steps are as follows:\n1. At site 1, O1 is executed first, transforming the document to "xabc." When O2 arrives, it must be transformed due to the impact of O1. O2 is transformed into O2\' = T(O2, O1) = Delete[3, 1], with the position parameter increased by 1 to account for the character insertion from the concurrent operation O1. Executing O2\' on "xabc" correctly deletes "c," resulting in the document "xab." (Note: If the original O2 were executed directly, "b" would be incorrectly deleted instead of "c.")\n2. At site 2, O2 is executed first, transforming the document to "ab." When O1 arrives, it is transformed into O1\' = T(O1, O2) = Insert[0, "x"]. In this case, the transformed operation O1\' is the same as the original O1 because the execution of O2 does not affect O1. Executing O1\' on "ab" inserts "x" at position 0, resulting in the document "xab," consistent with the document at site 1.\n\nIn summary, the core idea of OT is to transform editing operations into a new form under the impact of previously executed concurrent operations. This ensures the correct editing effect (preserving intention) and guarantees that the replicated documents remain consistent (convergence).'
    },
    {
        id: 'section3',
        htmlf: '<h2>',
        htmll: '</h2>',
        title: 'Undo Thought of the OT Algorithm',
        content: 'The basic idea of supporting "undo" in the OT (Operational Transformation) algorithm can be explained with a simple text editing scenario.\n\nAssume the initial text is "123," replicated at two collaborative sites. The following operations occur in this scenario:\n1. Step 1: A user at site 2 generates operation O1 = Insert[2, "y"] (insert character "y" at position 2), updating the document state to "12y." O1 is then transmitted to site 1 and executed as-is, making the document states consistent at both sites: "12y."\n2. Step 2: A user at site 1 generates operation O2 = Insert[0, "x"] (insert character "x" at position 0), updating the document state to "x12y." O2 is then transmitted to site 2 and executed as-is, keeping the document states consistent: "x12y."\n3. Step 3: After executing O1 and O2, the user at site 2 issues an undo command Undo(O1) to undo O1 (which is not the last executed operation). In an OT-based undo system, the inverse operation of O1 is first created: !O1 = Inverse(O1 = Insert[2, "y"]) = Delete[2]. Next, !O1 is transformed against O2, yielding !O\'1 = T(!O1, O2) = Delete[3]. Executing !O\'1 updates the document state to "x12," achieving the correct undo effect, removing the impact of O1 while retaining the effect of O2. If the original inverse operation !O1 = Delete[2] were executed directly, the document would incorrectly become "x1y," which is not the desired outcome.\n\nIn summary, the OT undo mechanism transforms the inverse operation of O (the operation to be undone) into a new form to achieve the correct undo effect. The correct undo effect should remove the impact of O while preserving the impact of other operations. In other words, the correct undo effect changes the document state to what it would have been if O had not been executed, while all other operations had.'
    },
    {
        id: 'section4',
        htmlf: '<h2>',
        htmll: '</h2>',
        title: 'Operation Compression Thought of the OT Algorithm',
        content: 'The basic idea of operation compression in the OT (Operational Transformation) algorithm can be illustrated with a simple text editing scenario.\n\nAssume the initial text contains the string "123," synchronized at two collaborative sites. At site 1, a user generates four operations sequentially: O1 = Insert[2, "X"] (insert character "X" at position 2), O2 = Insert[1, "abc"] (insert string "abc" at position 1), O3 = Insert[2, "Y"] (insert character "Y" at position 2), and O4 = Delete[7] (delete character "X" at position 7). These operations are recorded in an operation log L = [O1, O2, O3, O4] but are not immediately propagated after execution. The operation compression algorithm compresses the operations in the log L before propagating them to site 2.\n\nThe compression process is as follows:\n1. Step 1: The rightmost operation O4 is transposed with the adjacent operation O3: transpose(O3, O4) = [O\'4, O\'3], where O\'4 = Delete[6], and O\'3 remains the same as O3, resulting in L\' = [O1, O2, O\'4, O3].\n2. Step 2: O\'4 is then transposed with the new adjacent operation O2: transpose(O2, O\'4) = [O\'\'4, O\'2], where O\'\'4 = Delete[3], and O\'2 remains the same as O2, yielding L\' = [O1, O\'\'4, O2, O3].\n3. Step 3: O\'\'4 is checked against the new adjacent operation O1. Since they are complementary and overlap (i.e., they have no impact on the document), both O\'\'4 and O1 are removed from L, resulting in L\' = [O2, O3].\n4. Step 4: The overlapping operations O2 and O3 in L\' are merged into a single operation O\'2 = Insert[1, "aYbc"], giving the final result L\' = [O\'2].\n5. The final result L\' = [O\'2] replaces L = [O1, O2, O3, O4] and is propagated to the remote site for integration.\n\nIn summary, the core idea of OT operation compression is to transpose accumulated operations into the appropriate position and form in the log L, check for overlap or complementary relationships, and decide whether to merge or remove them to achieve "compression." This reduces the number of operations in L while preserving the original effect of L.'
    }
    ]);

  
  const activeSection = ref<string | null>(null);// 当前活跃的 section ID
  
  // 滚动到对应的 section
  const scrollToSection = (id: string) => {
    const sectionElement = document.getElementById(id);
    if (sectionElement) {
      sectionElement.scrollIntoView({ behavior: 'smooth' });
    }
  };
  
  // 监听滚动事件，更新 activeSection
  const updateActiveSection = () => {
    const sectionElements = sections.value.map(section => 
      document.getElementById(section.id)
    );
  
    // 找到当前可视范围内的 section
    for (const sectionElement of sectionElements) {
      if (sectionElement) {
        const rect = sectionElement.getBoundingClientRect();
        if (rect.top >= 0 && rect.top < window.innerHeight / 2) {
          activeSection.value = sectionElement.id;
          break;
        }
      }
    }
  };
  
  onMounted(() => {
    window.addEventListener('scroll', updateActiveSection);
  
    // 清除事件监听器
    onUnmounted(() => {
      window.removeEventListener('scroll', updateActiveSection);
    });
  });
  </script>
  
  <style scoped>
  
  .banner-image {
    width: auto; 
    height: 100%; 
    border-bottom-left-radius: 30px;
    border-bottom-right-radius: 30px;
  }
  
  .text-container {
    display: flex;
    margin-left: 100px;
  }
  
  .text {
    width: 60%;
  }
  
  .article-nav {
    position: fixed;
    top: 50px;
    right: 10px;
    z-index: 1000;
    width: 250px;
  }
  
  .article-nav ul {
    list-style: none;
    padding: 0;
  }
  
  .article-nav ul li {
    padding: 20px;
    cursor: pointer; /* 添加手形指针 */
  }
  
  .article-nav ul li:hover {
    background-color: rgba(175, 175, 175, 0.3);
    border-radius: 10px;
  }
  
  .article-nav ul li.active {
    background-color: rgba(225, 225, 225, 0.6);
    border-radius: 10px;
  }
  
  a {
    color: inherit; /* 继承父级颜色 */
    text-decoration: none;
  }
  
  li.active a {
    color: #CBA5D1;
    font-weight: 700;
  }
  
  
  </style>